## 1. HTTP 리퀘스트 메시지를 작성한다

#### 탐험여행은 URL 입력부터 시작한다

- URL은 http: 뿐만아니라 ftp:, file:, mailto: 로 시작하는것 등 여러가지가 있다.

- 브라우저는 몇개의 클라이언트 기능을 겸비한 복합적인 클라이언트 소프트웨어이며, 어느것을 사용하여 데이터에 액세스하면 좋을것인지 판단하는 재료가 필요하기때문이다.

![](https://velog.velcdn.com/images/dudwls0505/post/81802d23-a0b8-4889-941f-1052cd0e39ee/image.png)

- 액세스 할때의 프로토콜 종류가 쓰여있다.
ex) 액세스 대상이 웹서버라면 HTTP, FTP서버라면 FTP프로토콜을 사용한다. 


#### 브라우저는 먼저 URL을 해독한다

> 브라우저는 웹서버에 보내는 리퀘스트의 메시지를 작성하기위해 가장먼저 URL을 해독한다

예시
`http://www.lab.cyber.co.kr/dir1/file1.html`
- http: http프로토콜에 액세스 한다.
- // : 뒤에 이어지는 문자열이 서버의 이름임을 나타냄
- www.lab.cyber.co.kr : 웹 서버의 이름
- dir1/file1.html : 파일의 경로

#### 파일명을 생략한경우 

`http://www.lab.cyber.co.kr`
`http://www.lab.cyber.co.kr/`

-  대부분의 서버가 index.html 또는 default.html파일명을 설정해두기때문에, 파일명이 생략되어있다면 /index.html 또는 /default.html 파일을 액세스 하게된다. 

`http://www.lab.cyber.co.kr/whatisthis`

- whatisthis라는 디렉토리가 있으면 디렉토리명으로보고, 파일이 있으면 파일명으로 해석한다.

#### HTTP의 기본개념

URL을 해독하고나면 어디에 액세스해야되는지 결정이되며, http라면  브라우저는 HTTP프로토콜을 사용하여 웹서버에 액세스한다.

![](https://velog.velcdn.com/images/dudwls0505/post/f80e8a34-0b06-4871-938c-a6e30faa3940/image.png)

- URI : 액세스 대상(무엇을) 
- 메소드 : 어떻게 , 어떤동작을 하고싶은지 

웹서버에 리퀘스트 메시지가 도착하면 웹서버는 그 내용을 해독한후 결과 데이터를 응답메시지에 저장한다.

- GET : URI로 지정한 정보를도출, 주로 데이터를 조회할때 가장많이 사용된다.
- POST : 클라이언트에서 서버로 데이터를 송신한다. 폼에 입력한 데이터를 송신하는경우에 사용한다. 


#### HTTP 리퀘스트 메시지를 만든다

**request 메시지의 형태**

![](https://velog.velcdn.com/images/dudwls0505/post/6bb6614d-6dc1-4c37-9982-5fd7c53ce588/image.png)

- request Line:`<메소드><공백><URI><공백><HTTP 버전>`  request의 대략적인 내용을 알수있다.

- request Headers: `<필드명>:<필드값>`
request의 부가적인 정보를 나타내며, 공백 행까지 헤더가된다.

- request Message Body: `<메시지본문>`
클라이언트 -> 서버로 송신하는 데이터로 대표적으로 POST메소드를 이용할때 데이터가 들어간다.   
GET메소드 인경우에는 메소드와 URI만으로 웹서버가 무엇을 할지 판단할수있으므로 본문 송신데이터가 비어있다. 


#### 리퀘스트 메시지를 보내면 응답이 되돌아온다

**response 메시지의 형태**

![](https://velog.velcdn.com/images/dudwls0505/post/84439334-9da1-4af3-b2ab-022431ab9e44/image.png)

- Status Line: `<HTTP 버전><공백><응답코드><공백><응답 문구>`
응답코드에는 정상종료,오류,등 request의 실행결과를 나타내는 응답코드와 응답문구를 첫번째 행에 써야한다. 

- Response Message Body : `<메시지본문>` 
서버에서 클라이언트에 송신하는데이터

## 2. 웹서버의 IP주소를 DNS서버에 조회한다

#### IP주소의 기본

> 브라우저는 URL을 해독하거나 HTTP메세지를 만들지만, 메시지를 네트워크에 송출하는 기능은 없으므로 OS에 의뢰하여 송신한다.   
이때 URL안에 쓰여있는 서버의 도메인명에서 IP주소를 조사해야한다.    
OS에 송신을 의뢰할땐 도메인명이 아니라 IP주소로 메시지를 받을 상대를 지정해야되기때문이다.  
**즉, HTTP메시지를 만들고 나서 도메인명에서 IP주소를 조사하는 동작이 이루어진다.**

액세스 대상에 데이터가 도착하는 과정

![](https://velog.velcdn.com/images/dudwls0505/post/bc7fb997-1455-460a-8f93-ea5c9cdd8f61/image.png)

- 서브넷 : 허브에 몇대의 PC가 접속되었다면, 이것을 한개의 단위로 서브넷이라고 한다. 
- 라우터: 패킷을 중계하는 장치의 일종

xx동x번지 라는 형태로 네트워크 주소를 할당하게되는데 동에 해당하는 번호를 서브넷에 할당하고 번지에 해당하는번호를 컴퓨터에 할당한다

> 동에 해당하는것이 **네트워크번호** 번지에해당하는번호를 **호스트번호** 라고하며 
이 두주소를 합쳐서 **IP주소**라고한다.

송신측이 메시지를 보내면 서브넷안에 있는 허브가 가까운 라우터에 운반하고, 
 라우터가 액세스 대상 주소를 확인하고 그 주소의 방향으로 데이터를 중계한다(다음 라우터로). 서브넷의 허브가 라우터까지 메시지를 보내는 과정을 반복한다.

액세스 대상의 서버까지 메시지를 운반할때, ip주소에 따라 액세스 대상의 위치를 판단하고 운반한다.


- IP주소
`10.11.12.13`
  - 32비트의 디지털 테이터
  - 8비트씩 .으로 구분하여 10진수로 표기
  
- 넷마스크
`255.255.255.0` (10진수 표기)
`11111111.11111111.11111111.00000000`(비트로 표기)
  - IP주소 만으로는 네트워크번호/호스트번호를 구분하기가 힘들기때문에 존재
  - 넷마스크가 1인부분은 네트워크 번호를 나타내고 0인부분은 호스트번호를 나타내며,   
  모두1인경우에는 서브넷에있는 기기전체에 패킷을 보내는 **브로드캐스트**를  나타낸다  


#### 도메인명과 IP주소를 구분하여 사용하는 이유

> TCP/IP의 네트워크는 IP주소로 통신상대를 지정하기때문에 IP주소를 반드시 알아야하며, URL안에 서버명이 아닌 IP주소를 써도 제대로 작동한다. 
**하지만, 기억하기가 어렵기때문에 서버의 이름을 쓸수있도록 하는것이 좋다.**  
  
  
**그럼 아예 IP주소 관두고 이름으로 상대 지정하여 통신하는것이 좋지않을까?**  
=> IP주소는 32비트, 도메인명은 IP주소보다 훨씬큰 바이트를 잡아먹게된다.     
이는 라우터의 부하로 이어져 데이터를 운반하는 동작의 시간이 더 많이 걸릴수있다.  
  
  
#### Socket 라이브러리가 IP주소를 찾는 기능을 제공한다

도메인명으로 IP주소를 조회한다는것은  DNS서버에 요청/응답을 하게된다는 맥락과 비슷하다.  
이 DNS 클라이언트에 해당하는것을 **리졸버**라고 부른다. 

  
#### 리졸버 내부작동

![image](https://user-images.githubusercontent.com/59333182/171853385-8a3b870a-c037-42fc-ab0d-c765b134a888.png)


네트워크 애플리케이션이 리졸버 호출 -> 제어권이 리졸버의 내부로 넘어감 ->     

Socket라이브러리의 내용들이 실행되고  요청받은 작업들 실행 ->   

DNS서버에 문의하기위한 메시지 생성 (이 과정에서 OS내부에 프로토콜 스택을 호출하여 실행)  

-> LAN어댑터를 통해 메시지가 DNS서버를 향해 송신-> DNS서버에서 답을 찾아 응답 ->   

반환된 메시지를 프로토콜 스택을 경유하여 리졸버에 건네지고, 리졸버가 내용을 해독한후 IP주소를 추출하여 애플리케이션에 IP주소를 건네준다

-> 애플리케이션으로 제어가 돌아온다.


## 3. 전 세계의 DNS서버가 연대한다

#### DNS 서버의 기본동작
`www.naver.com` 이라는 이름을가진 서버의 IP주소를 조사하려고 할때, 클라이언트는 다음과 같은 정보를 포함한 조회메시지를 DNS서버에 보낸다.
> 이름 = www.naver.com
클래스 = IN(인터넷 네트워크를 의미)
타입 = A(IP 주소가아닌 다른 타입이라면 변경될수있다)

다음과같은 형식과 일치하는 것을 찾아 반환한다. 


#### 도메인의 계층

> 앞에서 살펴봤던 DNS서버에서 형식과 일치하는 IP주소를 찾는과정은  
> 한대의 DNS서버에 인터넷에 존재하는 막대한 수의 서버를 저장할수없다.  
**사실, 정보를 분산시켜 다수의 DNS서버에 등록하고 다수의 DNS서버가 연대하여 어디에 정보가 등록되어있는지 찾아내는 과정이다.**  

DNS서버에 등록된 정보는 계층구조를 가지게되며 `.`이 구분자가 된다.
`www.naver.com`이 존재한다면, com이라는 도메인아래에 naver라는 도메인이있고 그 안에 www라는 이름이 있게된다.


#### 담당 DNS 서버를 찾아 IP 주소를 가져온다

- 수많은 DNS서버가 존재하기때문에 일일히 뒤질수 없음
- `www.naver.com`이라는 도메인을 담당하는 DNS서버를  `naver.com`의 DNS서버에 등록하며, `com` DNS서버에 최종 등록하는방식

![](https://velog.velcdn.com/images/dudwls0505/post/fbe4328b-82b8-42e9-bc0f-10fdef7b0a90/image.png)


- 최상단에 루트 도메인이라는것도 존재하며, 루트 도메인의 DNS서버를 인터넷에 존재하는 DNS서버에 전부 등록하여 모든 DNS서버가 루트도메인에 액세스할수있게 된다. 

- 캐시 기능도 존재한다

흐름
요청받은 웹서버에 대한 정보(www.naver.com)를 조회 -> 가장가까운 DNS서버에 등록되어있지않음 ->  

루트도메인의 DNS서버가 가장 가까운 DNS서버에는 등록되어있으므로 루트도메인으로 찾고자하는 웹서버 정보를 전송 ->   

루트도메인에 존재하지않지만, com아래에있으므로 타고내려갔으나 없기때문에 다시DNS서버에 전달 -> naver.com도메인의 dns서버 ip주소를 반송  


## 4. 프로토콜 스택에 메시지 송신을 의뢰한다

#### 데이터 송수신 동작의 개요

IP주소를 찾고, 액세스 대상 웹서버에 메시지를 송신하도록 OS내부의 프로토콜 스택에 의뢰해야한다.
이 과정은 Socket라이브러리 프로그램의 결정된 순번대로 호출된다

![](https://velog.velcdn.com/images/dudwls0505/post/5cee310b-aaa5-46b7-ac70-df47a440ca3f/image.png)

데이터를 송수신하는 통로가 있는데, 이통로를 만들기전에 양끝에있는 소켓을 만들고 연결해야한다 
- 서버측에서 소켓을 생성
- 소켓에 클라이언트가 서버측 소켓에 파이프를 연결
- 데이터 송.수신
- 데이터를 전부보내고 파이프 분리 


#### 소켓의 작성 단계

소켓 라이브러리의 프로그램부품만 호출하면 소켓이 만들어진다.소켓이 생기면 디스크립터라는 번호표같은것으로 소켓을 식별한다(2개의 브라우저 창을 열경우 2개의 다른 웹서버에 접속할경우)


#### 파이프를 연결하는 접속 단계

- 디스크립터(컴퓨터 한대 내부에서 소켓을 식별하기위해 사용)
- 서버의IP주소
- 포트번호 => 접속 상대의 소켓을 지정할수있다.(접속 상대측에서 소켓을 식별하기위해 사용하며, 미리 결정된 포트번호를 사용한다)

3가지값을 지정하여 connect를 호출하여 의뢰 동작을 실행한다

#### 메시지를 주고받는 송수신 단계

소켓이 상대측과 연결되면 자유롭게 데이터를 전송할수있다.

![](https://velog.velcdn.com/images/dudwls0505/post/1cdcf3de-9489-49aa-889d-05696066fa8a/image.png)

-  애플리케이션은 송신데이터(입력한 URL바탕으로 생성한 HTTP 요청메시지)를 메모리에 준비한다
- write를 호출하여 디스크립터, 송신데이터를 지정한다
- 프로토콜 스택이 송신 데이터를 서버에 송신한다 
- 소켓에는 연결된 상대를 알고있으므로, 전달받은 디스크립터로 대상을 판별해 메시지를 전달한다. 

#### 연결끊기 단계

데이터 수신이 완료되면 close를 통해 연결끊는다
-> 소켓말소, 파이프라인 분리
