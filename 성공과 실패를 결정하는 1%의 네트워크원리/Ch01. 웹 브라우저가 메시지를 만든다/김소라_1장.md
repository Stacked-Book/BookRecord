## 01 HTTP 리퀘스트 메시지를 작성한다

---

### 브라우저

> 복합적인 클라이언트 소프트웨어
>

<br>

**기능**

- 웹 서버에서 액세스하는 기능(HTTP)
- 파일을 다운로드/업로드(FTP)
- 메일의 클라이언트 기능

<img width="648" alt="스크린샷 2022-06-02 오후 9 58 29" src="https://user-images.githubusercontent.com/80027033/171844728-8b2a8304-991c-4494-9339-8b58c4f050f8.png">

<br>

### HTTP

> 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것
>

1. 클라이언트에서 서버를 향해 리퀘스트 메시지를 보낸다.
    1. 무엇을 → URI(보통 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일명)
    2. 어떻게 해서 → 메소드
2. 웹 서버는 URI와 메시지를 조사하여 ‘무엇을', ‘어떻게 하는지' 판단한 후 요구에 따라 동작하고, 결과 데이터를 응답 메시지에 저장한다.
    1. 응답 메시지
        1. Status code : 실행 결과가 정상 종료되었는지 또는 이상이 발생했는지를 나타냄

           (예) ‘404 Not Found’

        2. 헤더 파일
        3. 페이지의 데이터
3. 응답 메시지를 클라이언트에 반송한다.
4. 클라이언트에 응답 메시지가 도착하여 브라우저가 메시지 안의 데이터를 추출하여 화면에 표시한다.

<br>

**메소드**

 | 메소드 | 의미 |
 | --- | --- |
 | GET | URI로 지정한 정보 도출. 파일의 경우 해당 파일의 내용을 되돌려 보내고, CGI 프로그램의 경우 해당 프로그램의 출력 데이터를 반송. |
 | POST | 클라이언트에서 서버로 데이터 송신. 폼에 입력한 데이터를 송신하는 경우에 사용. |
 | HEAD | GET과 유사. 단 HTTP 메시지 헤더만 반송하고 데이터의 내용을 돌려보내지 않음. |
 | OPTIONS | 통신 옵션을 통지하거나 조사할 때 사용. |
 | PUT | URI로 지정한 서버의 파일 치환. |
 | DELETE | URI로 지정한 서버의 파일 삭제. |
 | TRACE | 서버측에서 받은 리퀘스트 라인과 헤더를 그대로 클라이언트에 반송. |
 | CONNECT | 암호화한 메시지를 프록시로 전송할 때 이용. |

<br>

### 리퀘스트 메시지

<img width="477" alt="스크린샷 2022-06-02 오후 10 58 34" src="https://user-images.githubusercontent.com/80027033/171844798-bcda86ba-1233-408f-a81c-1a8af06a9aee.png">

**리퀘스트 메시지**

```
1 GET /sample1.html HTTP/1.1 
2 Accept: */*                
3 Accept-Language: ja
4 Accept-Encoding: gzip, deflate
5 ...
6 <공백>
7 <메시지 본문>
```

**1**     **리퀘스트 라인** : <메소드><공백><URI><공백><HTTP 버전>

**2〰️** **메시지 헤더** : 리퀘스트의 부가적인 정보

**7〰️** **메시지 본문** : 클라이언트에서 서버에 송신하는 데이터

<br>

**응답 메시지**

```
1 HTTP/1.2 200 OK
2 Date: 
3 Server:
4  ...
5 Content-Type: text/html
6
7 <html>
8 ...
9 </html>
```

**1**     **스테이터스 라인** : 리퀘스트의 실행결과를 나타내는 스테이터스 문구 + 응답 문구

**2〰️** **메시지 헤더**

**7〰️** **메시지 본문** : 서버에서 클라이언트에 송신하는 데이터. 바이너리 데이터로 취급.

<br>

**HTTP의 스테이터스 코드의 개요**

<aside>
🧑‍🎓 만약 한 페이지에 html 문장 파일과 jpg 사진 파일이 같이 있다면?
리퀘스트 메시지에 쓰는 URI는 하나뿐이므로, 복수의 파일을 읽을 대는 웹 서버에 별도의 리퀘스트 메시지를 보낸다. 그러므로 리퀘스트 메시지는 총 2회 전송된다.

</aside>

## 02 웹 서버의 IP 주소를 DNS 서버에 조회한다

---

### IP 주소

네트워크 번호 + 호스트 번호

<br>

**TCP/IP의 개념**

`서브넷`이라는 작은 네트워크를 `라우터`로 접속하여 전체 네트워크가 만들어진다.

<br>

<aside>
🧑‍🎓 서브넷이란?

**`허브`에 몇 대의 pc가 접속된 것**이다. 이것을 한 개의 단위로 생각하여 ‘서브넷’이라고 부르는데, **라우터에서 연결하면 네트워크 전체가 완성**된다.
</aside>

<br>

**데이터 도착 과정**

1. 송신측이 메시지를 보내면 `서브넷` 안에 있는 `허브`가 운반하고 가장 가까운 `라우터`까지 도착한다.
2. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고, 거기에 보내도록 지시하여 송신 동작을 실행한다.
3. 다시 서브넷의 허브가 라우터까지 메시지를 보낸다.

<br>

**IP 주소**

- 32비트, 8비트씩 구분
- 네트워크 번호와 호스트 번호 두 가지를 합쳐 32비트로 한다는 것만 결정되었을 뿐 내역은 결정되지 않아 구별할 수 없다.
- 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는데, 그 내역이 담긴 정보를 `넷마스크`라고 한다.
    - 넷마스크가 1인 부분은 네트워크 번호, 넷마스크가 0인 부분은 호스트 번호
- IP 주소의 호스트 번호
    - 모두 0 : 서브넷 자체를 가리킨다.
    - 모두 1 : 서브넷에 있는 기기 전체에 패킷을 보내는 ‘브로드캐스트’를 나타낸다.

<br>

### DNS 서버

> 서버명과 IP 주소를 대응시키기 위해 사용
>

**DNS 서버에 IP 주소 조회하기**

- 네임 리졸루션(name resolution) : DNS의 원리를 사용하여 IP 주소를 조사하는 것
- DNS 리졸버(resolver) : 리졸루션을 실행하는 것

<br>

### Socket Library

> OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것. 리졸버는 프로그램 부품 중 하나이다.
>

<br>

**리졸버를 이용하여 DNS 서버 조회**

리졸버의 프로그램명(`gethostbyname`)과 웹 서버의 이름을 써서 리졸버를 호출한다.

```java
<메모리 영역> = gethostbyname("www.lab.cyber.co.kr");
```

- 위처럼 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 송신, DNS 서버로부터 응답을 받는다.
- 응답 메시지 속 IP 주소를 추출하여 브라우저에서 지정한 메모리 영역에 써넣는다.
- 브라우저가 웹 서버에 메시지를 보낼 때는 이 메모리 영역에서 IP 주소를 추출하여 HTTP 리퀘스트 메시지에 함께 건네 주어 송신을 의뢰한다.

<br>

**리졸버 내부의 작동**

1. DNS 서버에 문의하기 위한 메시지를 생성한다.
2. OS의 내부에 포함된 `프로토콜 스택`을 호출하여 송신 실행을 의뢰한다.
3. LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다.
4. 조회 메시지가 DNS 서버에 도착하고 DNS 서버는 조사해 답을 찾는다.
5. 응답 메시지에 답을 담아 클라이언트에 반송한다.
6. 메시지는 네트워크를 통해  클라이언트측에 도착하고, 프로토콜 스택을 경유해서 리졸버에 건네진다.
7. 리졸버가 내용을 해독한 후 IP 주소를 추출하여 애플리케이션에 IP 주소를 건네준다.

✅ DNS 서버의 IP 주소는 컴퓨터에 미리 설정되어진다.

<br>

## 03 전 세계의 DNS 서버가 연대한다

---

### DNS 서버의 기본 동작

> 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일
>

**조회 메시지**

- 이름 : 서버나 메일 배송 목적지와 같은 이름
- 클래스 : IN(인터넷)
- 타입 : 어떤 타입(종류)의 정보가 지원되는지
    - A : 이름에 IP 주소가 지원, IP 주소를 조회할 때 사용
    - MX(Mail eXchange) : 이름에 메일 배송 목적지가 지원, 메일 배송 목적지를 조회할 때 사용

      (예) tone@cyber.co.kr 이라는 메일 주소가 있을 때 @ 뒤에 이름이 메일 배송 목적지가 되므로 이 이름을 조회한다.

    - 그외(PTR-IP주소에서 이름 조사, CNAME-이름에 별칭 부여 등)

<br>

**조회 과정**

조회 메시지

```
(a) 이름 = www.lab.cyber.co.kr
(b) 클래스 = IN
(c) 타입 = A
```

1. DNS 서버는 등록된 정보를 찾아서 이름, 클래스, 타입의 세 가지가 일치하는 것을 찾는다.
2. 세 가지 항목이 일치하는 리소스 레코드가 있다면 등록되어 있는 IP 주소 값을 클라이언트에 회답한다.

<br>

**도메인의 계층**

<aside>

🧑‍🎓 만약, 조회 메시지를 받은 DNS 서버에 정보가 등록되어 있지 않은 경우라면?
정보를 분산시켜 **다수의 DNS 서버에 등록**하고, **다수의 DNS 서버가 연대**하여 어디에 정보가 등록되어 있는지 찾아내는 구조로 작동한다.

</aside>

> DNS 서버에 등록한 정보에는 모두 **도메인명**이라는 계층적 구조를 가진 이름이 있다.
>

```
www.lab.cyber.co.kr
```

- dot(.)이 계층을 구분한다.
- 오른쪽에 위치한 것이 상위의 계층을 나타낸다.
- 하나의 부서에 해당하는 것을 `도메인`이라고 한다.
    - (예) ‘com사업부 cyber부 lab과의 www’

<br>

**특징**

- 한 대의 DNS 서버에 도메인 한 대를 등록한다.
- 도메인의 계층 구조와 같은 형태로 DNS 서버가 배치되며, 각 도메인의 정보는 그 도메인에 있는 DNS 서버에 등록된다.

<br>

**DNS 서버에 등록한 정보 찾기**

> 액세스 대상의 웹 서버가 어느 DNS 서버에 등록되어 있는지 찾아내는 방법
>
- 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록한다.(반복)
- 즉, 상위의 DNS 서버에서 하위의 DNS 서버의 IP 주소를 알게 해 조회 메시지를 보낼 수 있게 한다.

<aside>

🧑‍🎓 **루트 도메인**을 이용한다면?
최상위에는 `루트 도메인`이라는 도메인이 있다. 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록하면 어느 DNS 서버에서도 루트 도메인에 액세스할 수 있게 된다.

</aside>

![Untitled](https://user-images.githubusercontent.com/80027033/171845559-f0d3f089-20af-43e6-b282-7048ee917d92.png)

- 클라이언트에서 어딘가의 DNS 서버에 액세스한다.
- 루트 도메인을 경유하여 최종적으로 원하는 DNS 서버에 도착한다.

<br>

**DNS서버와 캐시**

- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답하기 때문이다.
- 이름이 존재하지 않는 경우에도 캐시에 저장되므로 빠르게 회답이 가능하다.
- 정보 변경의 가능성이 있기 때문에 유효 기한을 설정하고 사용해야 한다.

<br>

## 04 프로토콜 스택에 메시지 송신을 의뢰한다

---

### 데이터 송수신

**프로토콜 스택**

> OS 내부의 프로토콜 스택에 메시지 송신 동작을 의뢰할 때는 Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출한다.
>

<br>

**데이터 송수신 동작 단계**

1. 서버 측에서 소켓을 만들고 클라이언트가 파이프를 연결하기를 기다린다.
2. 클라이언트 측에서도 소켓을 만들고, 소켓에서 파이프를 늘려 서버측의 소켓에 연결한다.
3. 데이터를 송수신한다.
4. 송수신이 끝난 후 파이프를 분리(소켓 말소)할 때는 어느 쪽에서 분리해도 상관없다.

<br>

**소켓의 작성 단계**

- 클라이언트 측의 소켓을 만들기 위해 소켓 라이브러리의 `socket`을 호출한다.
- 소켓이 생기면 `디스크립터`라는 것이 돌아오고 애플리케이션은 이것을 메모리에 기록해 둔다.
    - 디스크립터  : 소켓을 식별하기 위해 사용하는 것으로 프로토콜 스택이 어느 소켓을 사용하여 접속할지 또는 데이터를 송수신할지 금방 판단할 수 있다.

<br>

**파이프를 연결하는 접속 단계**

- 애플리케이션은 Socket 라이브러리의 `connect`를 호출한다.
    - 세 가지 값
        - 디스크립터
        - 서버의 IP 주소
        - 포트 번호 : IP 주소와 포트 번호 두 가지를 지정해야 어느 컴퓨터의 어느 소켓과 접속할지를 분명히 지정할 수 있다.
- 프로토콜 스택이 접속 동작을 실행한다.
- 상대와 연결되면 프로토콜 스택은 연결된 상대의 IP 주소나 포트 번호 등의 정보를 소켓에 기록한다.

<br>

**송수신 단계**

- 상대측의 소켓에 데이터가 도착한다.
- 애플리케이션은 송신 데이터를 메모리에 준비한다.
- Socket 라이브러리의 `write`를 호출할 때 디스크립터와 송신 데이터르르 지정한다.
- 수신 할 때는 `read`를 호출하여 응답 메시지를 받고 마련된 메모리 영역인 `수신 버퍼`에 저장한다.
- 수신 버퍼에 메시지를 저장한 시점에 메시지를 애플리케이션에 건네준다.

<br>

**연결 끊기 단계**

- 먼저 웹 서버측에서 `close`를 호출하여 연결을 끊는다.
- 클라이언트측에도 전달되어 클라이언트의 소켓은 연결 끊기 단계에 들어간다.
- 브라우저가 `read`로 수신 동작을 의뢰했을 때 수신한 데이터를 건네주는 대신 송수신 동작이 완료되었다는 사실을 통보받고 브라우저에서도 close를 호출한다.