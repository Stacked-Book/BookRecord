# 6장 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다.

- **목차**

## 서버의 개요

---

### 1. 클라이언트와 서버의 차이점

> 클라이언트로부터 패킷을 수신 -> 처리 -> 응답
> 

**차이점**

- **하드웨어 OS는 다를 수 있다.**
    
    → 단 네트워크에 관한 부분 즉 LAN, 프로토콜 스택, Socket 라이브러리 등의 기능은 클라이언트와 다르지 않다.
    
- **기능은 같지만 사용법이 조금 다르다!**
    
    → 클라이언트는 접속을 해야하고, 서버는 받아야하기 때문에 Socket을 사용하는 방법은 다를 수 밖에 없다.
    
- 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화를 한다.
    
    → 서버 애플리케이션은 클라이언트 애플리케이션과 구조가 다를 수 밖에 없다.
    

### 2. 서버 애플리케이션 구조

> 서버는 동시에 복수의 클라이언트와 통신 동작을 실행하지만, 하나의 프로그램으로 여러 클라이언트들의 상대를 처리하기는 어렵다.
> 

**❓ 왜 힘들까?**

- 클라이언트와 어디까지 대화를 진행하고 있는지를 전부 파악해야 하기 때문입니다.
- 그러므로 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 서버 애플리케이션이 클라이언트와 1:1로 대화하는 방법을 선택하는 것이 일반적입니다.

![p392 그림 6-1](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/12611781-87ff-44a7-b86f-86963f8c9dd3/IMG_5127.jpg)

p392 그림 6-1

`a` : 접속을 기다림

`b` : 클라이언트1과 대화

`b`` 클라이언트2와 대화

- 서버 프로그램을 작동해서 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 `a` 실행
- 이후 `b` 를 작동시켜서 그곳에 접속이 끝난 소켓을 건네주는 동작을 계속하면 클라이언트와 대화하는 부분 `b` 는 접속이 끝난 소켓을 사용하여 클라이언트와 대화를 시작한다.
    - `b` 는 새 클라이언트가 접속할 때마다 잇달아 기동되므로 `b` 의 부분이 한 대의 클라이언트와 1:1로 대응하게 된다.

**서버 OS는 멀티태스크 또는 멀티스레드라는 기능에 의해 다수의 프로그램을 동시에 함께 작동할 수 있다.**

**❓ 이러한 방법에 단점은 없나?**

- 클라이언트가 접속했을 때 새로 프로그램을 기동하는 부분에서 다소 시간이 걸리고, 응답시간이 추가로 소요된다는 단점이 있다.
    
    ![클라이언트에서 오는 응답을 기다리는 모습 (blocking)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/276c183e-f37e-4d4c-9382-3651a3d787b8/Untitled.png)
    
    클라이언트에서 오는 응답을 기다리는 모습 (blocking)
    
    **이러한 단점을 해결할 방법도 존재한다!**
    
    - 미리 클라이언트와 대화하는 몇 개의 부분을 작동
    - 클라이언트가 접속했을 때 클라이언트의 상대를 처리하지 않는 비어있는 것을 찾아 여기에 접속한 소켓을 건네주어 
    클라이언트와 대화를 계속하는 방법도 존재한다.

### 3. 서버측의 소켓과 포트번호

**클라이언트와 서버의 차이점 간단 정리**

- 데이터를 송수신하는 동작의 관점에서는 클라이언트와 서버라는 상태로 역할을 고정시키는 것은 종은 방법이 아니다.
    
    ❓ **고정 시키면 더 편한게 아닌가?**
    
    - 다양한 형태로 액세스하는 애플리케이션이 있기 때문입니다.
- 이처럼 다양한 형태로 데이터를 송,수신 하는 구조를 지원하려면 데이터 송수신 구조에서 클라이언트와 서버라는 식으로 역할을 결정하지 말고 **좌우 대칭**으로 어디에서나 자유롭게 데이터를 송신할 수 있도록 해 두는 방법이 좋다.

**좌우대칭으로 만들 수 없는 부분도 존재한다.**

`접속동작` 이 그 예시이다.

- 한쪽이 가디라고 있는 곳에 또 한 쪽을 연결해야 한다.
- 양쪽이 동시에 접속하면 안 되며, 양쪽에서 기다려서도 안된다.
- 기다리지 않는 곳에 일방적으로 접속하는 것 또한 불가능하다.

이러한 부분만은 `접속하는 측` 과 `기다리는 측` 의 역할 분담이 필요하다.

즉 `접속하는 측` 이 클라이언트이고 `기다리는 측` 이 서버이다.

**클라이언트의 데이터 송수신 동작과 서버측**

- **클라이언트**
    1. 소켓을 만든다.(작성)
    2. **서버측의 소켓과 파이프로 연결(접속)**
    3. 데이터를 송수신(송수신)
    4. 파이프를 분리하고 소켓을 말소한다.(연결 끊기)
- **서버**
    1. 소켓을 만든다.(작성)
    2. **소켓을 접속 대기 상태로 만든다(대기 상태)**
        
        **접속을 접수한다.(접속 접수 단계)**
        
    3. 데이터를 송수신한다.
    4. 파이프를 분리하고 소켓을 말소한다.

**이처럼 2번 단계가 다른 것을 볼 수 있다.**

**❓ 포트번호는 식별을 하기 위한 것이므로 소켓마다 다른 값을 할당되는 것인가?**

매번 다른 값을 할당하기 위해서는 접속 대기 동작을 할 때 새로 만든 소켓에는 원래의 접속 대기 소켓과는 다른 포트 번호를 할당해야 합니다.

- 예시로 클라이언트에서 80번이라는 포트 번호의 소켓에 접속 패킷을 보냈을 때 이것과는 다른 포트 번호의 소켓에서 회답이 돌아옵니다.
- 이럴 경우 접속 패킷을 보낸 상대로부터 회답이 돌아왔는지, 아니면 다른 상대로부터 잘못된 회답의 패킷이 돌아왔는지 판별할 수 없게 된다.

**이러한 이유로 새로 만든 소켓에도 접속 대기 소켓과 같은 포트 번호를 할당해야만 합니다.**

**❓ 소켓에 같은 포트번호가 할당되면 문제가 없나 ?**

같은 번호로 할당한 여러 개의 소켓이 존재해서 포트 번호로 소켓을 지정할 수 없게 되는 문제가 생깁니다.

이러한 문제를 IP주소 및 추가적인 정보를 사용해서 해결합니다.

- 클라이언트의 IP 주소
- 클라이언트의 포트 버노
- 서버 측의 IP 주소
- 서버 측의 포트 번호

서버측의 소켓에도 같은 포트번호를 가진 여러 개의 소켓이 존재한다.

하지만 클라이언트측의 소켓은 모두 다른 포트 번호를 하랑하므로 클라이언트 측의 포트 번호에 따라 소켓을 지정할 수 있습니다.
