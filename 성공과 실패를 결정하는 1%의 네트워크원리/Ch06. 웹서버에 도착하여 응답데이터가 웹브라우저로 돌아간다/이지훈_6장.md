# 6장 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다.

## 서버의 개요

---

### 1. 클라이언트와 서버의 차이점

> 클라이언트로부터 패킷을 수신 -> 처리 -> 응답
> 

**차이점**

- **하드웨어 OS는 다를 수 있다.**
    
    → 단 네트워크에 관한 부분 즉 LAN, 프로토콜 스택, Socket 라이브러리 등의 기능은 클라이언트와 다르지 않다.
    
- **기능은 같지만 사용법이 조금 다르다!**
    
    → 클라이언트는 접속을 해야하고, 서버는 받아야하기 때문에 Socket을 사용하는 방법은 다를 수 밖에 없다.
    
- 서버의 애플리케이션은 동시에 다수의 클라이언트 PC와 대화를 한다.
    
    → 서버 애플리케이션은 클라이언트 애플리케이션과 구조가 다를 수 밖에 없다.
    

### 2. 서버 애플리케이션 구조

> 서버는 동시에 복수의 클라이언트와 통신 동작을 실행하지만, 하나의 프로그램으로 여러 클라이언트들의 상대를 처리하기는 어렵다.
> 

**❓ 왜 힘들까?**

- 클라이언트와 어디까지 대화를 진행하고 있는지를 전부 파악해야 하기 때문입니다.
- 그러므로 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 서버 애플리케이션이 클라이언트와 1:1로 대화하는 방법을 선택하는 것이 일반적입니다.

![image](https://user-images.githubusercontent.com/53300830/177539521-355e8874-8eb7-49c2-9311-e532ad9f30aa.png)

p392 그림 6-1

`a` : 접속을 기다림

`b` : 클라이언트1과 대화

`b`` 클라이언트2와 대화

- 서버 프로그램을 작동해서 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 `a` 실행
- 이후 `b` 를 작동시켜서 그곳에 접속이 끝난 소켓을 건네주는 동작을 계속하면 클라이언트와 대화하는 부분 `b` 는 접속이 끝난 소켓을 사용하여 클라이언트와 대화를 시작한다.
    - `b` 는 새 클라이언트가 접속할 때마다 잇달아 기동되므로 `b` 의 부분이 한 대의 클라이언트와 1:1로 대응하게 된다.

**서버 OS는 멀티태스크 또는 멀티스레드라는 기능에 의해 다수의 프로그램을 동시에 함께 작동할 수 있다.**

**❓ 이러한 방법에 단점은 없나?**

- 클라이언트가 접속했을 때 새로 프로그램을 기동하는 부분에서 다소 시간이 걸리고, 응답시간이 추가로 소요된다는 단점이 있다.
    
![image](https://user-images.githubusercontent.com/53300830/177539554-9af6dc18-26bc-49a5-8f9e-2e0faf96474e.png)
    
    클라이언트에서 오는 응답을 기다리는 모습 (blocking)
    
    **이러한 단점을 해결할 방법도 존재한다!**
    
    - 미리 클라이언트와 대화하는 몇 개의 부분을 작동
    - 클라이언트가 접속했을 때 클라이언트의 상대를 처리하지 않는 비어있는 것을 찾아 여기에 접속한 소켓을 건네주어 
    클라이언트와 대화를 계속하는 방법도 존재한다.

### 3. 서버측의 소켓과 포트번호

**클라이언트와 서버의 차이점 간단 정리**

- 데이터를 송수신하는 동작의 관점에서는 클라이언트와 서버라는 상태로 역할을 고정시키는 것은 종은 방법이 아니다.
    
    ❓ **고정 시키면 더 편한게 아닌가?**
    
    - 다양한 형태로 액세스하는 애플리케이션이 있기 때문입니다.
- 이처럼 다양한 형태로 데이터를 송,수신 하는 구조를 지원하려면 데이터 송수신 구조에서 클라이언트와 서버라는 식으로 역할을 결정하지 말고 **좌우 대칭**으로 어디에서나 자유롭게 데이터를 송신할 수 있도록 해 두는 방법이 좋다.

**좌우대칭으로 만들 수 없는 부분도 존재한다.**

`접속동작` 이 그 예시이다.

- 한쪽이 가디라고 있는 곳에 또 한 쪽을 연결해야 한다.
- 양쪽이 동시에 접속하면 안 되며, 양쪽에서 기다려서도 안된다.
- 기다리지 않는 곳에 일방적으로 접속하는 것 또한 불가능하다.

이러한 부분만은 `접속하는 측` 과 `기다리는 측` 의 역할 분담이 필요하다.

즉 `접속하는 측` 이 클라이언트이고 `기다리는 측` 이 서버이다.

**클라이언트의 데이터 송수신 동작과 서버측**

- **클라이언트**
    1. 소켓을 만든다.(작성)
    2. **서버측의 소켓과 파이프로 연결(접속)**
    3. 데이터를 송수신(송수신)
    4. 파이프를 분리하고 소켓을 말소한다.(연결 끊기)
- **서버**
    1. 소켓을 만든다.(작성)
    2. **소켓을 접속 대기 상태로 만든다(대기 상태)**
        
        **접속을 접수한다.(접속 접수 단계)**
        
    3. 데이터를 송수신한다.
    4. 파이프를 분리하고 소켓을 말소한다.

**이처럼 2번 단계가 다른 것을 볼 수 있다.**

**❓ 포트번호는 식별을 하기 위한 것이므로 소켓마다 다른 값을 할당되는 것인가?**

매번 다른 값을 할당하기 위해서는 접속 대기 동작을 할 때 새로 만든 소켓에는 원래의 접속 대기 소켓과는 다른 포트 번호를 할당해야 합니다.

- 예시로 클라이언트에서 80번이라는 포트 번호의 소켓에 접속 패킷을 보냈을 때 이것과는 다른 포트 번호의 소켓에서 회답이 돌아옵니다.
- 이럴 경우 접속 패킷을 보낸 상대로부터 회답이 돌아왔는지, 아니면 다른 상대로부터 잘못된 회답의 패킷이 돌아왔는지 판별할 수 없게 된다.

**이러한 이유로 새로 만든 소켓에도 접속 대기 소켓과 같은 포트 번호를 할당해야만 합니다.**

**❓ 소켓에 같은 포트번호가 할당되면 문제가 없나 ?**

같은 번호로 할당한 여러 개의 소켓이 존재해서 포트 번호로 소켓을 지정할 수 없게 되는 문제가 생깁니다.

이러한 문제를 IP주소 및 추가적인 정보를 사용해서 해결합니다.

- 클라이언트의 IP 주소
- 클라이언트의 포트 버노
- 서버 측의 IP 주소
- 서버 측의 포트 번호

서버측의 소켓에도 같은 포트번호를 가진 여러 개의 소켓이 존재한다.

하지만 클라이언트측의 소켓은 모두 다른 포트 번호를 하랑하므로 클라이언트 측의 포트 번호에 따라 소켓을 지정할 수 있습니다.
![image](https://user-images.githubusercontent.com/53300830/177549946-9574aa2f-7d6d-499f-a9d8-21d3704a7952.png)
![image](https://user-images.githubusercontent.com/53300830/177549905-59698747-9c18-4c22-9e17-7f65625a0dae.png)

[출처]([url](https://github.com/Road-of-CODEr/one-percent-network/blob/master/20201118/Chapter6.md))

## 서버의 수신 동작

---

서버에 도착한 부분부터 다시 시작!

### 1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다.

> 서버의 도착하는 패킷의 실체는 전기나 빛의 신호이고 수신하는 동작은 클라이언트와 똑같다.
> 

**수신동작은 패킷의 신호를 LAN 어댑터에서 수신하고 디지털 데이터로 바꾸는 부분에서 시작된다.**

→ 클럭 신호를 추출하여 데이터를 0과 1로 이루어져있는 디지털 데이터로 바꾼다.

**프리앰블 부분에서 클록을 추출한다.**

프리앰블 부분은 신호가 **일정 간격으로 규칙적으로 변화**한다.

위 내용을 토대로 타이밍을 조사하면 클록이 어느 위치에 있는지 알 수 있다.

- 마이너스 → 플러스 : 1
- 플러스 → 마이너스 : 0

**FCS를 통해 패킷의 오류 유무를 검사한다.**

- 패킷의 맨 마지막에 존재한다.
- 패킷의 맨 끝에 있는 값은 송신할 때 전기 신호로 변환하기 전의 디지털 데이터를 바탕으로 계산한 것이므로 신호에서 되돌린 디지털 데이터가 송신 전과 같으면 계산한 값과 맨 끝에 있는 값은 일치한다는 방식을 이용한 것이다.
    
    **❓ 만약 일치하지 않다면 되돌려 보내나?**
    
    일치하지 않을 경우는 제 역할을 하지 못하는 것이므로 그냥 폐기해버립니다.
    

**맨 앞의 MAC 헤더에 있는 수신처가 본인인지 확인한다.**

**❓ MAC헤더의 수신처가 다른데 올수가 있나?**

이더넷은 **LAN 전체에 신호를 흘리고 상대를 찾는 형태**이기 때문에 올바른 패킷이 아니더라도 도착할 수 있기 때문입니다.

수신처가 본인이 아닌 패킷은 버립니다.

- 변환 디지털 데이터를 LAN 어댑터 내부의 버퍼 메모리에 저장한다.(여기까지가 LAN의 MAC이 담당한다.)
- LAN 어댑터에서 CPU에게 인터럽트 방식을 이용해 패킷이 도착했다는 사실을 알린다.
- CPU는 LAN 드라이버로 실행을 전환한다.
    - LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출
    - 프로토콜을 판별하고 적합한 프로토콜 처리 소프트웨어를 호출한다.
        
        → TCP/IP인 경우 해당 프로토콜을 호출하여 패킷을 건낸다 
        

### 2. IP 담당 부분의 수신 동작

> 프로토콜 스택에 패킷이 전달되면 우선 IP 담당 부분이 동작하여 IP 헤더를 점검한다.
> 

서버에서 라우터와 같이 패킷을 중계하는 기능이 유효하게 된 경우에는 자신을 대상으로 하지 않는 패킷이 도착할 수도 있다.

→ 라우터와 같이 경로표에서 중계 대상을 조사하고 그것에 패킷을 중계한다.

**조각 나누기에 의해 패킷이 분할됐는지 조사한다.**

- IP헤더를 조사하면 분할됐는지 확인할 수 있다.
- 분할돼 있는 경우
    - 패킷을 일시적으로 메모리에 저장 → 조각이 전부 도착해야 하나의 패킷으로 사용할 수 있기 때문이다.
- 분할돼있지 않다면 패킷 조립 동작은 필요가 없다.

**IP프로토콜 번호 항목을 조사하여 해당하는 담당 부분에 패킷을 건네준다.**

- 번호가 06이라면 TCP, 11이면 UDP 이런 방식으로 건네주게 된다.

**간단정리**

IP 헤더 점검 → 자신을 대상으로 한 것인지 → 조각 나누기 (분할돼있는 경우만) → TCP, UDP 담당 부분에 패킷 건네주기

### 3. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작

> TCP 담당 부분의 동작은 도착한 패킷의 내용에 따라 달라지게 된다.
> 

**패킷의 TCP 헤더에 있는 SYN이라는 컨트롤 비트가 1로 되어 있으면 접속 동작이다.**

- 그 전에 도착한 패킷의 수신처 포트 번호를 조사하여 같은 번호를 할당한 접속 대기 소켓 있는지 확인
- 같은 같은 포트 번호의 **접속 대기 소켓이 없으면 잘못된 것**이므로 오류 통지 패킷을 클라이언트에게 반송
- 해당하는 접속 동작이 존재한다면 패킷을 복사하여 새 소켓을 만든다.
    - 송신처의 IP주소, 포트 번호, 시퀀스 번호의 초기값, 윈도우의 값 등 필요한 정보 기록
    - 동시에 송신 버퍼나 수신 버퍼로 사용하는 메모리 영역을 확보한다.
    - 패킷을 받았다는 ACK 번호, 서버에서 클라이언트에 보내는 데이터에 관한 시퀀스 초기값, 클라이언트에서 서버로 보내온 데이터를 받기 위한 수신 버퍼의 빈 용량을 나타내는 윈도우 값 등을 기록한 TCP 헤더를 만든다.
    - 이것들을 IP 담당 부분에 의뢰하여 클라이언트에게 반송한다.

이렇게 패킷이 클라이언트에 도착하면 **패킷을 받았음을 나타내는 ACK 번호가 돌아오게 된다**. 
이것이 돌아오면 접속 동작은 완료된 것이다.

![image](https://user-images.githubusercontent.com/53300830/177550024-b6b649c3-48c7-493b-90f3-5ff43df13930.png) 

[출처]([url](https://like-grapejuice.tistory.com/69))

이때 서버측은 accept를 호출하여 실행을 쉬는 상태이다. 

여기에 새로 만든 소켓의 디스크립터를 전달하여 서버 애플리케이션의 동작을 재개하게 된다.

**간단 정리**

TCP 담당일 때 → 헤더의 SYN 비트 확인 → 수신처 포트 번호 조사 → 해당하는 접속 대기 소켓 복사 → 송신처의 IP 주소나 포트 번호 기록

### 4. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작

> 송수신 단계에 들어가서 데이터 패킷이 도착한 경우의 동작의 내용입니다.
> 

**TCP 담당 부분은 도착한 패킷이 어느 소켓에 해당하는지 조사한다.**

- IP헤더의 송신처 IP주소, 수신처 IP주소, TCP 헤더의 수신처 포트 번호, 송신처 포트 번호 → 4개의 정보 사용
- 해당 소켓을 발견할 경우
    - 패킷에 기록된 정보를 통해 올바르게 데이터 송수신이 이루어지고 있는지 확인
        
        → 시퀀스 번호, 데이터 조각의 길이 등등을 확인
        
    - 패킷에서 데이터 조각을 추출하여 수신 버퍼에 저장 (분할 하기 전의 상태로 되돌린 상태)

**수신 확인 응답용 TCP 헤더를 만든다.**

- 수신 패킷의 시퀀스 번호와 데이터 조각의 길이로부터 계산한 ACK 번호를 기록
- IP 담당 부분에 의뢰하여 클라이언트에 반송
- 수신 버퍼에 기록된 데이터들은 소켓 라이브러리의 `read` 함수 호출을 통해 어플리케이션에 넘겨진다.
- 애플리케이션에서 http 리퀘스트 메시지 내용을 조사하고 브라우저에서 데이터를 반송한다.

**간단정리**

TCP 담당 부분은 도착한 패킷의 송신처 등 4개의 정보를 이용해 소켓을 판단 → 데이터 조각을 연결 해서 수신 버퍼에 보관 → 클라이언트에게 ACK 를 되돌려준다.

### 5. TCP 담당 부분의 연결 끊기 동작

> 어느 쪽(클라이언트 or 서버) 에서든 연결 끊기 동작에 들어가도 상관없다.
HTTP 1.0 이라면 서버에서 연결 끊기 동작을 시작한다.
> 
- 서버에서 `close` 함수를 호출하고 FIN 1로 설정한 TCP 헤더를 클라이언트에게 보낸다.
- 클라이언트도 `close` 를 호출하고 FIN 1로 설정하여 반송하고 ACK도 보낸다.
- 잠시 기다렸다가 소켓을 말소한다.
