## 01 서버의 개요

---

🔎 클라이언트와 서버의 차이점

같은 기능을 가지고 있어도 *클라이언트는 접속 동작*을 수행하고, *서버는 기다리는 형태*가 되기 때문에 동작이 다르다. 또한 서버는 용도에 따라 다양한 종류가 있고 동시에 다수의 클라이언트 PC와 소통한다.

<br>

**서버 애플리케이션의 구조**

<img width="618" alt="스크린샷 2022-07-08 오후 2 46 25" src="https://user-images.githubusercontent.com/80027033/177974453-ee459227-2fae-4972-83c8-b240ce3d2b1f.png">

① 서버 프로그램을 작동해 설정 파일 읽기 등 초기화 동작을 마쳤을 때 `(a)`를 실행한다.

② `(a)`에서 소켓을 작성하고 소켓을 클**라이언트에서의 접속 동작을 기다리는 상태**로 만든채 쉬는 상태로 만들고 언제든지 클라이언트가 접속했을 때 다시 작동하여 접속을 기다린다.

③ `(b)`를 작동시켜 접속이 끝난 소켓을 건네받고 클라이언트와 대화를 한다.

- 새 클라이언트가 접속할 때마다 새 태스크/스레드를 생성해 새로 생성한 소켓을 (b)에 건네주면 클라이언트와 **1 대 1**로 통신할 수 있게 된다.

④ 대화가 끝나면 연결을 끊고 종료한다.

<br>

<img width="639" alt="스크린샷 2022-07-08 오후 3 33 10" src="https://user-images.githubusercontent.com/80027033/177974563-a7854e69-24fd-423b-a875-f826da7b254b.png">


(1) socket을 호출하여 소켓을 만든다.

(2-1) bind를 호출하여 소켓에 포트 번호를 기록하고 listen을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록한다.

(2-2) accept를 호출하여 접속을 접수한다.

- 애플리케이션에서 접속 패킷이 도착하면 응답 패킷을 반송하여 접속 접수 동작 실행
- 접속 대기의 소켓을 복사하여 새로운 소켓을 만들고, 접속 상대의 정보를 비롯한 제어 정보를 새 소켓에 기록

(3) 데이터 송,수신

(4) 연결 끊기

<br>

🔎 새롭게 만들어진 소켓이 대기 소켓과 같은 포트 번호로 생성되면 어떻게 소켓을 식별할 수 있을까?

→ 클라이언트측의 포트 번호와 IP 주소에 따라 소켓을 지정한다.

**소켓 지정에 사용하는 네 가지 정보**

- 클라이어트측의 IP 주소
- 클라이언트측의 포트 번호
- 서버측의 IP 주소
- 서버측의 포트 번호
- 디스크립터

<br>

## 02 서버의 수신 동작

---

### **패킷 수신 동작**

<img width="752" alt="스크린샷 2022-07-08 오후 4 42 44" src="https://user-images.githubusercontent.com/80027033/177974725-570799d9-c27d-499d-9bb9-7c311ec27a0a.png">

① `프리앰블` 부분에서 `클록`을 추출한다.

② 클록을 같은 간격으로 연장한다.

③ 클록의 위치에서 신호의 변화의 방향을 조사한다.

④ 신호의 변화가 디지털 데이터의 1과 0에 대응되므로 신호의 변화를 디지털 데이터에 대응시킨다.

⑤ `프레임 체크 시퀀스(FCS)`로 오류 유무를 검사한다.

⑥ 데이터를 `LAN 어댑터` 내부의 `버퍼 메모리`에 저장한다.

⑦ `LAN 드라이버`가 MAC 헤더로부터 프로토콜을 판단하여 `프로토콜 스택`에 패킷을 건네준다.

<br>

**IP 담당 부분**

⑧ IP 헤더를 점검하고 TCP/UDP에 패킷을 건네준다.

- 자신을 **대상**으로 한 것인지 판단
- 조각 나누기에 의한 패킷의 **분할**이 있는지 조사
- TCP 담당 부분 또는 UDP 담당 부분에 패킷 전달

<br>

**TCP 담당 부분**

👍 *접속 패킷을 수신했을 때*

> TCP 헤더에 있는 SYN이라는 컨트롤 비트가 1로 되어 있으면 접속 동작의 패킷
>

① 도착한 패킷의 수신처 포트 번호를 조사하여 이 번호와 같은 번호를 할당한 접속 대기 상태의 소켓이 있는지 확인한다.

② 접속 대기 소켓을 복사해 새 소켓을 만들고 필요 정보를 기록한다.

- 송신처의 IP 주소/포트번호
- 시퀀스 번호의 초기값
- 윈도우의 값 등

③ 송신 버퍼나 수신 버퍼로 사용하는 메모리 영역을 확보한다.

④ TCP 헤더를 만들어 IP 담당 부분에 의뢰하여 클라이언트에 반송한다.

- ACK 번호 : 패킷을 받았다는 의미
- 시퀀스 번호의 초기값 : 서버에서 클라이언트에 보내온 데이터에 관한 값
- 윈도우 값 : 수신 버퍼의 빈 용량

⑤ 클라이언트에서 패킷을 받았음을 나타내는 ACK 번호를 받으면 접속 동작은 완료된다.

<br>

✌️*데이터 패킷을 수신했을 때*

① 도착한 패킷이 어느 소켓에 해당하는지 조사한다.

- `IP 헤더`의 송신처/수신처의 IP 주소
- `TCP 헤더`의 수신처/송신처 포트번호

② 패킷에 기록되어 있는 데이터 송수신 동작이 올바르게 진행되고 있는지 점검한 후 패킷에서 데이터 조각을 추출하여 수신 버퍼에 저장한다.

③ 수신 버퍼에 저장한 후 수신 확인 응답용 TCP 헤더를 만들어 반송한다.

<br>

## 03 웹 서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다

---

> `read`에서 받은 데이터의 내용이 HTTP 리퀘스트 메시지에 기록되어 있는 내용에 따라 적절한 처리를 실행하여 응답 메시지를 만들고, `write`를 통해 이것을 클라이언트에 반송한다는 형태로 작동한다.
>
- URI의 경우
    - 리퀘스트 메시지의 URI는 웹 서버의 디스크가 무방비 상태로 노출되지 않기 위해 만든 가상의 디렉토리이다.
    - 파일을 읽어올 때 실제 디렉토리의 경로명으로 변환 후 파일을 읽어 데이터를 반송한다.
- `CGI`(Common Gateway Interface)의 경우
    - URI의 부분에 쓰여있는 파일명을 조사하여 프로그램인지 판단
    - 프로그램을 작동시키도록 OS에 의뢰하고 받은 데이터를 처리하여 출력 데이터를 웹 서버에 되돌려준다.

<br>

## 04 웹 브라우저가 응답 메시지를 받아 화면에 표시한다

---

> 화면 표시 동작은 응답 메시지에 저장된 데이터가 어떤 종류인지를 조사하는 것부터 시작하며 응답 메시지의 맨 앞부분에 있는 `Content-Type`이라는 헤더 파일의 값으로 판단하는 것이 원칙이다.
>

<img width="517" alt="스크린샷 2022-07-08 오후 7 19 23" src="https://user-images.githubusercontent.com/80027033/177974913-6971e933-e826-47f3-bde6-b94bebebd089.png">

- 데이터의 종류가 텍스트일 경우 `charset`으로 문자 코드의 정보 부가
- `Content-Encoding`  : 원래의 데이터를 변환했을 경우 사용
- 파일의 확장자나 데이터 내용의 포맷으로 판단할 수 있음
- 실제 화면 표시 동작은 OS가 담당하므로 화면 위치/문자/글꼴 표시를 지시