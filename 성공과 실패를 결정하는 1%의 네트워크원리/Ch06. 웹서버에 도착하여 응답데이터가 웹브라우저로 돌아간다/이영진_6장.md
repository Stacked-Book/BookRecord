# 서버의 개요

#### 클라이언트와 서버의 차이점

- 서버는 하드웨어,OS부분에서 클라이언트와 일부 다른점이있다

- 네트워크에관한 ( LAN어댑터, 프로토콜 스택, Socket 라이브러리등) 기능은 클라이언트와 다른점이 없다.

#### 서버 애플리케이션의 구조

- 서버는 복수의 클라이언트와 통신동작을 개별로 처리하기위해 클라이언트가 접속할때마다 새로 서버프로그램을 작동하여 클라이언트와 대화하는방법을 선택한다 

![](https://velog.velcdn.com/images/dudwls0505/post/330779c1-3a76-4562-9f7c-dfa84fae84dd/image.png)

- 여러 요청이온다면 OS가 멀티태스크, 멀티스레드를 이용해 여러 요청을 처리한다

- 접속을 기다리는부분과 대화하는 부분을 나누어서 하는 방법이다
=> 접속할때만 접속을기다리는부분(a)을 실행하고 새 클라이언트가 접속할때마다 대화하는부분(b)을 새로 기동시킨다 


#### 서버측의 소켓과 포트번호

- 서버는 접속을위해 접속대기상태가 될수있다 

- 접속대기상태인 포트로 접속요청이 온다면    
접속대기소켓을 복사하여 새소켓을 만들고  새소켓을 클라이언트측의 소켓과 접속한다 

- 새로 소켓을 만들더라도 포트번호는 동일한 번호를 할당한다   
=> 동일한 포트번호를 가진 여러 소켓이 존재해서 포트번호만으로 특정 소켓을 지정할수가 없게되는 문제가 발생하기때문에   
클라이언트측의 IP,포트번호 서버측의 IP,포트번호까지 사용한다

- 그럼 소켓하나하나를 구별하던 디스크립터는 필요없지않나?
=> 소켓 생성이후 접속하지않은 상태에서는 위의 4가지 정보를 사용할수 없기때문에  디스크립터는 필요하다



# 서버의 수신동작

#### LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다

- 수신동작시 패킷신호를 LAN어댑터에서 수신하고 패킷을 디지털 데이터로 변환후 FCS라는 오류검사용 데이터로 오류 유무를 검사한다

- 오류가없는것을 확인하면 MAC헤더를 확인하여 수신처가 자신인지 확인후 아닌패킷은 버린다.

- 인터럽트를 통해 CPU로 패킷이 도착했음을 알린다

- LAN드라이버로 동작이 넘어오고 메모리에서 수신한패킷을 추출하고 MAC헤더를 확인하여 프로토콜 스택에 맞게 패킷을 건네준다 


> 그후, 프로토콜 스택의 IP담당부분이 IP헤더를 점검하여  패킷이 자신을 대상으로 한것인지 판단하며
조각나누기로 패킷이 분할되었는지 조사하고, TCP담당부분 혹은 UDP담당부분에 패킷을 건네준다



#### TCP담당부분이 접속패킷을 수신했을때의 동작

- 패킷의 TCP헤더에 SYN비트가 1인것을 확인하면 접속동작의 패킷인것을 인지하고 
도착한 패킷의 수신포트번호와 일치하는 접속대기상태의 소켓이 있는지  확인하고 적합하지않으면 클라이언트에 오류통지 패킷을 반송한다

- 일치하는 접속대기상태의 소켓이 존재하다면 패킷을 복사하여 새 소켓을 생성하고 송신처의 IP주소, 포트번호, 시퀀스번호의 초기값등의 정보를 기록한다

- 패킷을 받았음을 ACK번호,소켓에 기록한 정보를 포함한 TCP헤더를 만들고 IP담당 부분에 의뢰하여 클라이언트에 반송한다

- 클라이언트에 패킷이 정상 도착하면 ACK번호가 반송되며 접속동작이 완료된다


#### TCP담당부분이 데이터패킷을 수신했을때의 동작

- 수신된 패킷이 어느소켓에 해당되는지를 찾는과정 

- 이전에 필요했던 4가지의 정보 (IP헤더의 송신처 IP주소, 수신처IP주소, TCP헤더의 수신처 포트번호와 송신처 포트번호) 가 일치하는 소켓을 찾는다

- 소켓을 찾으면 패킷에 기록되어있는 데이터를 점검하고 수신 버퍼에 저장한다. 

- ACK번호를 기록하고 IP담당부분에 의뢰하여 클라이언트에 반송한다


# 웹서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다


#### 조회의 URI를 실제 파일명으로 변환한다

- HTTP 요청메시지의 URI에 기록되어있는 파일을 그대로 디스크에서 읽는것이 아닌 가상의 디렉토리를 실제 디렉토리로 변환하는 과정을 거친다

- www.naver.com 입력시  www.naver.com/index.html 과같은 페이지가 화면에 표시될수있다

#### CGI 프로그램을 작동하는경우

- URI에 HTML문서가 아닌 프로그램 파일의 이름을 사용할수도 있다. 이경우 해당하는 프로그램을 작동시켜 프로그램의 출력데이터를 클라이언트에 반송한다

- 프로그램에서 처리하는 데이터를 HTTP 요청메시지 안에 넣어 브라우저에서 웹서버로 보내는 방식이다

- 웹서버는 URI부분의 파일명을 조사하여 프로그램인지 판단한다 (프로그램용 디렉토리명을 설정하거나, 확장자를 등록해두는 방법이 있다)

- 프로그램인걸 인식하면 OS에 작동을 의뢰하고 요청메시지에서 데이터를 추출하여 작동시킨 프로그램에 건네준다

- 출력데이터를 웹서버에 되돌려준다(보통 HTML문서 형식으로 되어있다)

#### 웹서버로 수행하는 액세스 제어

- 클라이언트의 주소, 도메인명, 사용자명과 패스워드로 특정조건에 따라 액세스 동작여부를 설정할수있다


- 접속을 접수했을때 IP주소를 점검하거나 IP주소에서 도메인명을 조사할때 DNS서버를 사용하는 방식으로 동작여부를 점검한다

- 사용자명과 패스워드로 설정하는경우 웹서버가 사용자명과 패스워드를 기록하거나 리퀘스트 메시지를 보내도록 응답메시지에서 클라이언트에 통지한다

- 사용자명, PW 입력화는 화면을 브라우저가 표시한다

- 리퀘스트 메시지에 입력받은걸 기록하고 서버에 다시 액세스하며 액세스를 허가한경우 데이터를 반송한다 




# 웹브라우저가 응답메시지를 받아 화면에 표시한다

#### 응답데이터의 형식을보고 본질을 판단한다

- 응답메시지의 Content-Type 이라는 헤더필드의 값으로 데이터의 종류를 판단한다
=> 웹에서 취급되는 데이터가 다양하기 때문에

- Content-Type: text/html
