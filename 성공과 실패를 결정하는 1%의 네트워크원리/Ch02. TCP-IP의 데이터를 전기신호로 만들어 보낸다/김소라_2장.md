## 01 소켓을 작성한다

---

### 프로토콜 스택의 내부 구성

<img width="884" alt="스크린샷 2022-06-10 오후 2 16 17" src="https://user-images.githubusercontent.com/80027033/173063847-d6a36fcf-4003-487c-a467-93b053e63391.png">

- TCP : 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송수신 할 경우 사용
- UDP : DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송수신할 경우에 사용
- ICMP : 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지할 때 사용
- ARP : IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용
- LAN 드라이버 : LAN 어댑터의 하드웨어 제어
- LAN 어댑터 : 실제 송수신 동작, 케이블에 대해 신호를 송수신하는 동작 실행

<br>

### 소켓=통신 제어용 제어 정보

> 포로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며 여기에 통신 동작을 제어하기 위한 제어 정보를 기록하고 이 정보를 참조하면서 동작한다.
>

**제어 정보**

- 통신 상대의 IP 주소
- 포트 번호
- 통신 동작의 진행 상태(응답 여부, 송신 동작 후의 경과 시간 등)

<br>

### 소켓을 호출했을 때의 동작

<img width="635" alt="스크린샷 2022-06-10 오후 3 38 52" src="https://user-images.githubusercontent.com/80027033/173063981-d4a708cd-30ac-4665-892a-3ca8dec1c333.png">

**① 준비**

- 소켓 한 개 분량의 메모리 영역 확보
- 초기 상태임을 나타내는 제어 정보를 소켓의 메모리 영역에 기록
- 소켓이 만들어지면 소켓을 나타내는 `디스크립터`를 애플리케이션에 통지
- 디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송수신을 의뢰할 때 디스크립터를 통지

<br>

## 02 서버에 접속한다

---

### 미리 보는 개념

<img width="774" alt="스크린샷 2022-06-10 오후 4 47 28" src="https://user-images.githubusercontent.com/80027033/173064067-904881f8-ff53-4351-b1d9-ae4977c9e252.png">

**제어정보 - TCP 헤더**

| 필드 명칭 | 길이(비트) | 설명 |
| --- | --- | --- |
| 송신처 포트 번호 | 16 | 이 패킷을 송신한 측의 프로그램의 포트 번호 |
| 수신처 포트 번호 | 16 | 이 패킷을 받는 상대 프로그램의 포트 번호 |
| 시퀀스 번호 | 32 | 이 패킷의 맨 앞 위치의 데이터가 송신 데이터의 몇 번째 바이트에
해당하는지를 송신측에서 수신측에 전달하기 위한 것 |
| ACK 번호 | 4 | 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에
전달하기 위한 것.  |
| 데이터 오프셋 | 6 | 데이터 부분이 어디부터 시작하는지, 헤더의 길이. |
| 컨트롤 비트 | 6 | 각 비트가 각각 통신 제어상의 의미를 지님 <br> - URG : 긴급 포인터의 필드 유효 <br> - ACK : 보통 데이터가 올바르게 수신측에 도착한 것 의미 <br> - PSH : flush 동작에 의해 송신된 데이터 <br> - RST : 접속을 강제 종료, 이상 종료 시에 사용 <br> - SYN : 송신측과 수신측에서 일련번호를 서로 확인, 접속 동작을 나타냄 <br> - FIN : 연결 끊기 |
  | 윈도우 | 16 | 수신측에서 송신측에 윈도우 사이즈(수신 확인을 기다리지 않고
  묶어서 송신할 수 있는 데이터 양)를 통지하기 위해 사용 |
  | 체크섬 | 16 | 오류 유무 검사 |
  | 긴급 포인터 | 16 | 긴급하게 처리해야 할 데이터의 위치 |
  | 옵션 | 가변 길이 | 위의 헤더 필드 이의외 제어 정보 기록 |
→ 통신 상대와의 사이에 **제어 정보**를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만들어야 한다.

<br>

**② 접속(데이터를 송수신할 수 있는 상태로 만드는 과정)**

```
connect(<디스크립터>, <서버측의 IP주소와 포트 번호>, ...)
```

1. `<<클라이언트 측>>`

***애플리케이션***

- 서버측의 IP 주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달

***TCP 담당***

- 접속을 나타내는 제어 정보를 기록한 `TCP 헤더`를 생성하여 TCP 헤더의 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정한다.
    - SYN 컨트롤 비트 : 1
- TCP 헤더를 IP 담당 부분에 전달해 송신하도록 의뢰

***IP 담당***

- 패킷 송신 동작 실행

1. `<<서버 측>>`

***IP 담당***

- 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 TCP 헤더를 TCP 담당 부분에 전달

***TCP 담당***

- TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓 발견
- 해당 소켓에 필요한 정보 기록 후 TCP 헤더 생성, 응답 전달
    - ACK 컨트롤 비트 : 1(패킷을 받았다는 의미)

***IP 담당***

- 클라이언트에 응답 반송

1. `<<서버 측>>`
- IP 담당 부분을 경유하여 TCP 담당 부분에 패킷 도착
- TCP 헤더 조사하여 서버측의 접속 동작이 성공했는지 확인(SYN이 1이면 접속 성공)
- 소켓에 서버의 IP 주소, 포트 번호 등과 함께 접속 완료를 나타내는 제어 정보 기록
- 패킷이 도착한 것을 서버에 알리기 위해 ACK 비트를 1로 만든 TCP 헤더 반송

<br>

## 03 데이터를 송수신한다

---

> 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 자체적으로 내부에 존재하는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다린다.
>

**송신 동작 판단 요소**

1. **한 패킷에 저장할 수 있는 데이터의 크기**

<img width="1256" alt="스크린샷 2022-06-10 오후 6 36 00" src="https://user-images.githubusercontent.com/80027033/173064493-7e55de2b-2ae9-4319-97ad-b555514be1e3.png">

- Preamble : 수신 시스템에 이더넷 프레임이 시작됨을 알리고 동기화 시작
- SFD : 다음 바이트 부터 MAC 주소 필드가 시작됨 고지
- MTU : 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이
- MSS : 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
- FCS : 프레임의 끝 부분에서 오류 검출 역할

<br>

💡 **MSS의 길이를 초과할 경우?**

송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신

<br>

2. **타이밍**

프로토콜 스택의 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행한다.

- 프로토콜 스택에만 맡긴다면 송신 동작이 지연될 수 있으므로 버퍼에 머물지 여부를 결정하는 옵션을 개발자가 지정한다.

<br>

**데이터 송신 확인 동작**

> 패킷 누락을 확인 하기 위한 동작이다.
>
- `시퀀스 번호` : 맨 앞부터 세어서 몇 번째 바이트인지 계산
    - 악의적인 공격을 대비하여 난수를 바탕으로 산출한 초기값으로 시작
- `ACK 번호` : 이전에 수시한 데이터와 합쳐 데이터를 몇 번째 바이트까지 수신했는지 계산(최종으로 수신한 바이트 수 + 1)

  (예) 맨 앞부터 세어 1번째 바이트일 때

  시퀀스 번호 : 1, 크기 : 1,460바이트

  ACK 번호 : 1461

<img width="542" alt="스크린샷 2022-06-10 오후 7 25 19" src="https://user-images.githubusercontent.com/80027033/173064709-f5507325-2571-4d30-b8a7-1bd95d5b0107.png">

- 시퀀스 번호의 초기값은 양쪽에서 산출하고 접속 동작을 할 때 서로 상대에게 통지한다.
- 항상 상대가 데이터를 받은 것을 확인할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관한다.
- ACK 번호가 도착하지 않으면 전부 검출하여 회복 처리(패킷을 재전송)한다(TCP의 역할).

<br>

**ACK 번호 관리**

> 타임 아웃 값이란, ACK 번호가 돌아오는 것을 기다리는 시간이다.
>
- **핑퐁 방식** : 송신 측은 무조건 수신 측으로부터 ACK 번호를 받은 후 다음 패킷을 보낸다.
    - 장점 : 수신측의 능력을 초과하여 패킷을 보내는 일이 없다.
    - 단점 : ACK 번호가 돌아올 때까지 데이터 전송이 지연된다.
- **윈도우 제어 방식** : ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보낸다.
    - 수신측에서 송신측에 **수신 가능한 데이터 양**을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실행할 수 있다.
    - 위의 데이터 양은 TCP 헤더의 `윈도우 필드(윈도우 사이즈)`에 추가하여 전송한다.


<img width="534" alt="스크린샷 2022-06-10 오후 7 26 21" src="https://user-images.githubusercontent.com/80027033/173064817-d8744b0f-a9d6-41ea-93b8-2158d2e8877c.png">

① 클라이언트가 SYN을 1로 만든 TCP 헤더를 만들어 서버에 보낸다.

TCP 헤더 구성

- 클라이언트가 서버에 데이터를 보낼 때 사용하는 **시퀀스 번호의 초기값**
- 서버에서 클라이언트에 데이터를 송신할 때 이용하는 **윈도우**의 값

  (주로 송신 동작 실행 전에 수신측에서 송신측에 통지한다.)


② 서버에서 클라이언트 측의 정보를 받았다는 ACK 번호와 함께 TCP 헤더를 전송한다.

③ 클라이언트가 서버에 ACK 번호를 전송한다.

④ TCP는 데이터를 적당한 크기의 조각으로 분할하고 TCP 헤더를 맨 앞에 부가하여 서버에 보낸다.

- 송신 데이터가 몇 번째 바이트부터 시작되는지를 나타내는 시퀀스 번호가 기록되어 있다.

⑤ 서버는 ACK 번호를 반송한다.

- 데이터 송수신이 진행되면 수신 버퍼에 빈 영역이 생기게 되는데 이때 윈도우의 값도 기록하여 클라이언트에 통지한다.

⑥ 서버가 응답 메시지를 반송한다.

⑦ 클라이언트 측에서 ACK 번호를 전송한다.

<br>

## 04 서버에서 연결을 끊어 소켓을 말소한다.

---

<img width="563" alt="스크린샷 2022-06-10 오후 7 35 02" src="https://user-images.githubusercontent.com/80027033/173064948-4fc69486-d98b-484c-bb71-3f1529c5cc26.png">

① 서버측의 애플리케이션이 먼저 Socket 라이브러리의 close()를 호출한다.

② 서버측의 프로토콜 스택이 TCP 헤더를 만들고 컨트롤 비트의 FIN을 1로 설정한 후 IP 담당 부분이 클라이언트에 송신한다.

③ 서버에서 TCP 헤더가 도착하면 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록하고 ACK 번호를 반송한다.

④ 애플리케이션이 read를 호출하여 데이터를 가지러 오면 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트측의 애플리케이션에 알린다.

⑤ 클라이언트측의 애플리케이션도 close()를 호출하고 같은 동작을 반복한다.

⑥ 모든 과정이 끝이 난 후 오동작 방지를 위해 잠시 기다린 후 소켓을 말소한다.

<br>

## 05 IP와 이더넷의 패킷 송수신 동작

---

<img width="480" alt="스크린샷 2022-06-10 오후 7 54 50" src="https://user-images.githubusercontent.com/80027033/173065020-209026b1-f1b5-4714-938f-1dcad8402660.png">

### IP

**패킷 운반 과정 - 기본**

- 패킷의 송신처가 되는 기기가 패킷을 만드는데, 헤더에는 적절한 제어 정보를 기록하고 데이터 부분에는 얼마간의 데이터를 넣은 후 패킷을 가장 가까운 중계 장치에 송신한다.
- 패킷이 가장 가까운 중계 장치에 도착하고, 중계 장치는 도착한 패킷의 헤더를 조사하여 패킷의 목적지를 판단한다.
- 패킷의 헤더에 기록되어 있는 수신처와 수신처의 방향에 대한 표에 등록된 내용을 결헙하여 패킷의 목적지를 판단한다.

  (예) ‘xxxx’라는 주소는 xxxx번째 케이블’

- xxxx번째 케이블에 패킷의 신호를 송신하면 패킷은 다음 중계 장치에 도착한다.
- 차례로 패킷을 중계하면 최종적으로 수신처의 기기에 패킷이 도착한다.

<br>

**패킷 운반 과정 - TCP/IP의 패킷 구조**

- 송신처에서 패킷의 목적지가 되는 액세스 대상 서버의 IP 주소를 IP 헤더의 수신처에 기록한다.
- IP는 수신처가 어느 방향에 있는지 조사하고, 그 방향에 있는 다음 라우터를 조사한다.
- 다음 라우터에 할당된 이더넷의 주소(MAC주소)를 조사하고, 그것을 MAC 헤더에 기록하고 이더넷에 패킷 운반을 의뢰한다.
- 허브에 도착하면 패킷의 목적지를 판단하여 중계한다.
- 다음 라우터에 도착하면 어느 라우터에 패킷을 중계하면 좋을지 결정되고 다음 라우터의 MAC 주소를 조사하고, 이것을 MAC 헤더에 기록한다.
- 반복하여 목적지에 도착한다.

<br>

**패킷 송수신 동작**

- TCP 담당 부분이 데이터의 조각에 TCP 헤더를 부가한 것을 IP 담당에 넘겨준다.
- IP 담당 부분은 그 앞에 제어 정보를 기록한 헤더를 부가한다.
    - IP 헤더 : IP용 헤더, IP 주소 기록
    - MAC 헤더 : 이더넷용 헤더, MAC 주소 기록
- 이렇게 만든 패킷을 네트워크용 하드웨어에 건네준다.(이하 LAN 어댑터)
    - (예) 이더넷, 무선 LAN 등
- LAN 어댑터에 의해 전기나 빛의 신호 상태로 바뀌어 케이블에 송출된다.
- 신호는 허브나 라우터 등의 중계 장치에 도착하고, 중계 장치가 상대가 있는 곳까지 패킷을 전달한다.
- 상대에게 패킷이 도착하면 회답이 돌아온다.

<br>

**MAC 헤더**

- 송신처 MAC 주소
- 수신처 MAC 주소
    - `ARP`(Address Resolution Protocol)을 이용하여 이더넷에 연결되어있는 전원에게 패킷을 전달(브로드 캐스트)하여 해당 IP 주소의 MAC 주소를 알아낸다.
    - 한 번 조사한 결과는 ARP 캐시에 보존하여 다시 이용 가능하다.(일정 시간 경과 후 삭제)
- 이더 타입 : 사용하는 프로토콜의 종류

<br>

### 이더넷

> 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술
>

**이더넷의 성질**

- MAC 헤더의 수신처 MAC 주소에 기억된 상대에게 패킷을 전달한다.
- 송신처 MAC 주소로 송신처를 나타낸다.
- 이후 이더 타입으로 패킷의 내용물을 나타낸다.

<br>

**LAN 어댑터**

<img width="621" alt="스크린샷 2022-06-10 오후 8 47 52" src="https://user-images.githubusercontent.com/80027033/173065166-9b904807-3ffb-4ebf-b89b-8d5046c95e2e.png">

- 버퍼 메모리 : 송수신하는 패킷을 일시적으로 저장하는 메모리
- MAC : 충돌 검출/다시 송신 등 이더넷의 송수신 동작을 제어하는 부분
- ROM : MAC 주소를 기입하는 부분
- RHY(MAU) : 신호를 송신하는 회로와 신호를 수신하는 회로를 합친 것
- RJ-45 커넥터 : LAN 케이블을 접속하는 커넥터
- 송신시 ⬇, 수신 시 ⬆

<br>

**이더넷 패킷의 송수신 동작**

① 초기화 작업

전원을 공급하여 OS를 시동할 때 LAN 드라이버가 하드웨어의 초기화 작업을 수행하는데 이때 여러 초기화 작업 중 하나가 MAC 회로에 MAC 주소를 설정하는 것이다

② LAN 드라이버는 IP 담당 부분에서 패킷을 받으면 그것을 LAN 어댑터의 버퍼 메모리에 복사한다. 복사를 마친 후 패킷을 송신하도록 MAC 회로에 명령을 보내면 MAC 회로의 작업이 시작된다.

③ MAC 회로의 작업

- 먼저 송신 패킷을 버퍼 메모리에서 추출한다.
- 맨 앞에는 프리앰블과 스타트 프레임 딜리미터, 맨 끝에는 FCS를 부가하여 케이블에 송출하는 패킷을 완성시킨다.

④ 데이터 송신

- 반이중 모드(리피터 허브 사용) : 먼저 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 조사하고 신호가 흐르고 있으면 끝날 때까지 기다린 후 송신 동작을 시작한다.
    - MAC 회로가 프리앰블부터 1비트씩 차례로 데지털 데이터를 전기 신호로 변환
    - PHY 또는 MAU라는 송수신 신호 부분에 전송하면 PHY(MAU)는 신호를 케이블에 송출하는 형식으로 변환하여 송신한다.

      → 수신 신호선에서 신호가 들어오지 않으면 송수신 동작 완료

      → 충돌이 발생하면 재밍 신호를 보내고 대기 후 다시 송신 동작을 시도한다.

- 전이중 모드(스위칭 허브 사용)

⑤ 데이터 수신

④~③의 역순. MAC회로의 역할이 끝나면 패킷을 수신한 사실을 컴퓨터 본체에 통지(인터럽트)한다.

- 인터럽트 동작
    - LAN 어댑터가 확장 버스 슬록 부분에 있는 인터럽트용 신호선에 신호를 보낸다.
    - CPU와 연결되어 있기 때문에 신호가 흘러오면 CPU는 실행하던 작업을 보류하고 OS 내부의 인터럽트 처리용 프로그램쪽으로 전환한다.
    - LAN가 호출되어 LAN 어댑터를 제어하면서 송수신 동작을 실행한다.

<br>

**응답 패킷을 IP에서 TCP로 넘기기**

***IP 담당***

- 서버에서 반송된 패킷의 타입을 확인 후 해당하는 프로토콜 스택에 패킷을 건넨다.
- IP 헤더 부분부터 조사하여 문제가 없는지 확인하고 수신처 IP 를 조사한다.
- `리어셈블링(reassembling)` : 분할된 패킷이 전부 도착하기를 기다렸다가 패킷을 원래의 모습으로 되돌린다.
    - 수신한 패킷이 분할된 것이라면 IP 헤더의 `플래그`라는 항목을 보면 확인이 가능하다.
    - IP 헤더에 있는 `ID 정보`가 같은 값을 가진 패킷은 분할된 것이다.
    - `fragment offset`을 통해 패킷이 원래 패킷의 어느 위치에 있었는지 확인이 가능하다.

***TCP 담당***

- IP 헤더에 기록된 수신처 IP 주소와 송신처 IP 주소, TCP 헤더에 기록된 수신처 포트 번호 및 송신처 포트 번호의 네 가지 항목을 조사하여 해당하는 소켓을 찾는다.
- 소켓에 기록된 통신의 진행 상태를 확인하고 상황에 따라 적절한 동작을 실행한다.

<br>

## 06 UDP 프로토콜을 이용한 송수신 동작

---

- 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다.
- 제어용 짧은 데이터
    - 한 개의 패킷으로만 끝나는 경우가 많으므로 TCP와 같은 수신 확인이나 윈도우 정보를 주고받을 필요가 없다.
- 음성 및 동영상 데이터
    - 결정된 시간 안에 빠르게 데이터를 건네주어야 한다.
    - 데이터가 다소 없어도 치명적인 문제가 발생하지 않는다.