## 소켓을 작성한다 

####  프로토콜 스택의 내부구성

![](https://velog.velcdn.com/images/dudwls0505/post/1153039f-fdc1-45ef-bb7b-975e7d716d69/image.png)


- 브라우저나 메일등의 일반적인 애플리케이션이 데이터를 송수신할경우엔 TCP를 사용한다
- DNS 서버에 대한 조회등 짧은 제어용 데이터를 송수신할경우엔 UDP를 사용한다
- IP프로토콜을 사용하여 패킷의 형태로 데이터를 송수신 한다 
  - ICMP는 패킷을 운반할때 발생하는 오류를 통지하거나 제어용 메시지를 통제할때 사용한다
  - ARP는 IP주소에 대응하는 이더넷의 MAC주소를 조사할때 사용한다
  
- LAN드라이버는 LAN어댑터의 하드웨어를 제어한다  


#### 소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택은 내부에 제어정보를 기록하는 메모리영역을 가지고있다
=> 이영역이 **소켓의 실체**라고 볼수있다

- 프로토콜 스택이 제어정보를 참조하면서 동작한다 ( 소켓에 기록되어있는 상대측의 IP주소,포트번호를 대상으로 데이터를 송신한다)

- 응답이 돌아오는지 여부와 송신동작후의 경과시간등이 소켓에 기록되어있으며, 프로토콜 스택은 이 저보를 보고 포기하거나 다시보내는 동작을 하게된다 


#### 소켓을 호출했을때의 동작
![](https://velog.velcdn.com/images/dudwls0505/post/a68b9b00-ec91-4752-a4e3-b06b49266a64/image.png)

1. 소켓 작성 
- 소켓을 만들것을 의뢰하고 소켓 하나를 만든다 
- 프로토콜 스택은 소켓 한개 분량의 메모리영역을 확보한다
- 초기상태라는것을 메모리영역에 기록한다
- 소켓이 만들어지면 디스크립터로 소켓을 구분할수있는 번호표와 같은 정보를 애플리케이션에 알린다


## 서버에 접속한다

#### 접속의 의미

> 통신상대와의 사이에서 제어정보를 주고받아 소켓이 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 동작

- 클라이언트의 프로토콜 스택은 소켓을 만든직후 송신의뢰가 와도 통신상대를 알수없는 상태이다
=> 소켓을 만드는것만으로는 프로토콜 스택에 전달되는게 없기때문에
  - 서버의 IP주소나 포트번호를 프로토콜 스택에 알려야한다. 브라우저는 URL을 바탕으로 서버의IP주소와 포트번호를 조사하지만 이 정보만으론 부족하다  ( 접속동작의 역할중 일부)

- 서버측에서도 소켓이 만들어지지만 만들어지는동작 만으론 통신 상대를 알수없다
  - 그래서, 클라이언트에서 IP주소와 포트번호에대한 정보를 서버측에 전달한다. (접속동작의 역할중 일부) 
  
- 데이터 송수신동작을 할때 송수신 데이터를 저장하는 메모리영역,  버퍼 메모리라 불리는 영역을 확보한다  

접속의 첫번째 단계는 통신상대와의 제어정보(IP주소, 포트번호)를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는것이다.
  
  
#### 제어정보를 기록한 헤더를 맨앞부분에 배치한다

제어정보 
- 클라이언트와 서버사이에 주고받는 패킷의 맨앞부분에 부가되는 정보 
- 접속동작의 단계라면 데이터 송수신이 일어나지 않으므로 데이터가 없고 패킷의 제어정보만 으로 이루어져있다.
- ** 헤더의 형태로 제어정보를 주고받는다 **


#### 접속 동작의 실체

connect(<디스크립터>, <서버측의 IP주소와 포트번호>)

![](https://velog.velcdn.com/images/dudwls0505/post/a68b9b00-ec91-4752-a4e3-b06b49266a64/image.png)

- TCP담당부분에 요청이 전달되고 데이터 송수신 동작의 개시를 나타내는 제어정보를 기록한 헤더를 만든다

- 헤더의 중요한점중 하나는 송신처와 수신처의 포트번호, 이 포트번호로 인해 클라이언트/서버 에서 송수신처가 되는 소켓을 지정할수있게된다

- 제어 정보를 기록한 TCP헤더를 만들고 송수신처의 포트번호로 접속하는 소켓을 지정하는게 핵심이다. 

- TCP헤더를 만들고 IP담당부분에 건네어 송신을 의뢰하게되면 IP담당부분이 패킷 송신 동작을 실행하고 패킷이 서버에 도착하면 서버측의 IP담당부분이 이것을 받고 TCP담당부분에 건네준다 

- 접속이 되었다(송수신처가 정해졌다)는 컨트롤비트인 SYN을 1로 만든다 

- 클라이언트와 마찬가지로 송신처와 수신처의 포트번호,SYN비트를 설정한 TCP헤더를 만들고 응답을 돌려보낼때 ACK이라는 컨트롤비트도 1로 만든다 (패킷을 받았다)


## 데이터를 송수신한다

#### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- connect를 거쳐 제어가 돌아오면 write를 호출하여 송신동작을 실행하는데  받은 데이터의 내용을 알지못한다 

- 데이터를 버퍼 메모리영역에 저장하고 **패킷에 저장할수있는 데이터의 크기에 따라**(MTU) 곧바로 저장한 데이터를 보내거나 저장후 송신을할지 판단합니다 
=> MTU : 디지털 데이터의 최대길이(데이터 + IP헤더,TCP헤더)  MSS: 데이터의 최대길이 
=> 패킷길이가 길어져 효율이 높아질순있지만 버퍼에 머무는 시간만큼 송신동작이 지연될수있다

- 또하나의 판단요소는 타이밍 , 애플리케이션의 송신속도가 느려지는경우 MSS에 가깝게 데이터를 저장하면 지연될 여지가있어 일정시간 경과하면 패킷을 송신한다 
=> 지연이 적어지지만 이용 효율이 떨어진다. 

**이러한 선택,옵션들은 개발자의 몫이다**


#### 데이터가 클때는 분할하여 보낸다

송신 버퍼에 저장된 MSS의 길이를 초과한 데이터는 MSS크기에 맞게 분할하고 분할한조각을 한개씩 패킷에 넣어 송신한다


#### ACK번호를 사용하여 패킷이 도착했는지 확인한다

- TCP담당 부분에서 시퀀스번호라는 항목을 TCP헤더에 기록한다 
=> 시퀀스번호는 데이터의 조각을 송신할때 세어둔값

- 헤더에 기록하기때문에 송신하는 데이터의 크기도 전달할필요가 없다 
=> 패킷 전체의 길이에서 헤더길이를 빼면 데이터의 길이를 알수있기때문이다
=> 누락여부도 이덕분에 확인할수있다

- 누락이 없는것을 확인하면 이전의 데이터와 합쳐서 몇번째 바이트까지 수신했는지 계산하고 그값을 TCP헤더의 ACK번호에 기록하여 송신측에 알린다
=> ACK번호에 값을 설정할뿐아니라 , 제어비트의 ACK비트도 1로 한다 



> 시퀀스번호와 ACK번호의 대화
시퀀스번호의 초기값을 서버에 보냄 
-> ACK번호(받았다는 신호) + 시퀀스번호의 초기값을 서버에서 산출한값을 같이 포함하여 보냄
-> 데이터 송수신동작 돌입(데이터 + 시퀀스번호를 보냄) 
-> 서버에서 ACK번호를 반송 

TCP는 이 방법으로 상대가 데이터를 받은것을 확인한다 
송신한 데이터에 대응하는 ACK번호가 돌아오지않으면 패킷을 다시 보낸다 

오류를 검출할수있으며, 다시 요청을 보낼수 있게끔 할수도있다 
시퀀스번호 + ACK번호로 패킷이 수신측에 도착한것을 확인한다 


#### 패킷 평균 왕복시간으로 ACK번호의 대기시간을 조정한다

ACK번호의 반환동안 기다리는 시간을 조정할수가있는데(여러 변수에 의해 반환시간이 지연될수도,빨리올수도있다.)
TCP는 이 대기시간을 동적으로 변경하는방법을 취한다  ACK번호의 반환이 지연된다면 대기시간도 늘리고 
곧바로 돌아온다면 대기시간도 짧게 설정한다 


#### 윈도우 제어방식으로 효율적으로 ACK번호를 관리한다

- 한개의 패킷을 보내고 ACK번호를 기다렸다가 그다음 패킷을 보내는것이 아닌 한개의 패킷을보내고 연속해서 복수의 패킷을 보내게 하여 ACK번호를 기다리는 시간을 절약한다

- 한개씩 보낸다면 그렇지않겠지만, 복수의 패킷을 보내는방법은 수신측이 감당할수있는 패킷 이상을 보낼수있다는 문제가있다.
=> 패킷을 수신하면 버퍼메모리에 일시보관하는데 이 메모리가 터지게되는것

이때 수신가능한 데이터양을 통지하고 수신측은 이 양을 초과하지않도록 실행하는것이 윈도우 제어방식이다 

![](https://velog.velcdn.com/images/dudwls0505/post/09d79b1c-b7b8-428a-a4bf-f2e55088b856/image.png)


수신 버퍼에 데이터를 임시보관하고 수신처리가 끝나고 빈부분이 생겼다는 알림(이때가 윈도우 통지의 타이밍이다)을 TCP헤더의 윈도우필드에서 송신측에 알린다 . 


#### HTTP 응답 메시지를 수신한다 

수신한 데이터조각 + TCP헤더의 내용을 조사하여 데이터 누락여부 확인후 문제가없으면 ACK번호를 반송한다 



## 서버에서 연결을 끊어 소켓을 말소한다


#### 데이터보내기를 완료했을때 연결을 끊는다

![](https://velog.velcdn.com/images/dudwls0505/post/967a6df7-3f28-417d-8989-0fbfe593347d/image.png)


서버에측에서 먼저 연결을끊는다는가정
- 소켓 라이브러리 close호출하면 서버측의 프로토콜 스택이 TCP헤더를 만들고 FIN비트를 1로 설정한다

- 클라이언트측의 프로토콜 스택은 서버측이 연결끊기 들어갔다는것을 기록하고 FIN을 1로 설정한 패킷을 받은 사실을 알리기위해 ACK번호를 서버측에 반송하고 애플리케이션이 데이터를 가지러올때까지 대기한다 

- 애플리케이션이 read를 호출한다 

- 서버에서 서버에서 보낸 데이터를 전부 수신완료했다는 사실을 알리고 클라이언트가 종료된다 (ACK번호가 돌아온다) 


#### 데이터 송수신 동작을 정리한다 

TCP프로토콜에서 애플리케이션의 데이터를 송수신하는 동작

-- 접속동작 --
1. 서버측에서 소켓을 생성한다
2. 클라이언트에서 SYN을1로만든 TCP헤더(초기 시퀀스번호 포함)를 만들고 서버를 향해 접속한다
3. 서버에서 SYN을1로 만든 TCP헤더가 돌아온다

-- 송수신동작 --
4. TCP가 클라이언트가 보내는 리퀘스트 메시지를 적당한 크기로 분할하고 TCP헤더를 맨앞에 부가하여 서버에 보낸다
5. 이때 TCP헤더에 몇번째 바이트부터 시작되는지 시퀀스번호가 존재하며 서버가 ACK번호를 반송한다 
6. 최초의 데이터조각을 받은경우 받기만하고 애플리케이션에 데이터를 다시 전달한다면 수신버퍼에 빈영역이 생기고 이때 윈도우의값 (버퍼의 감당크기)을 기록하여 클라이언트에 알린다
7. 서버가 응답메시지를 보낸다


## IP와 이더넷의 패킷 송수신 동작

#### 패킷의 기본

패킷은 헤더+ 데이터의 부분으로 구성된다
라우터가 목적지를 확인하고, 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착한다

IP가 목적지를 확인하여 다음 IP의 중계장치를 나타낸다
서브넷안에있는 이더넷이 중계장치까지 패킷을 운반한다
![](https://velog.velcdn.com/images/dudwls0505/post/5decda78-7838-4bbb-8ddf-1140ddc538ce/image.png)

TCP/IP패킷은 MAC헤더(이더넷용헤더), IP헤더(IP용 헤더)도 붙어있다. 

이 IP헤더에는 액세스 대상 서버의 IP주소를 기록하여 패킷의 목적지를 정해주며 IP는 다음 라우터를 조사한다 
이때 다음 라우터에 할당된 MAC주소를 조사하고 그것을 MAC헤더에 기록하여 어느 라우터에 패킷을 도착시키면 좋은지를 전달한다


1. 이더넷의 원리에 따라 움직이는 허브에 도착 , 허브에는 패킷의 목적지를 판단하는 지표가있어서 목적지를 판단하여 중계한다

2. 중계되어 다음라우터에 도착하고 , 라우터에는 IP용표 + IP헤더의 수신처를 결합하여 다음에 어느라우터 패킷을 중계하면 좋을지 결정된다

3. 다음 라우터에대한 MAC주소를 조사하여 MAC헤더에 기록하고 다음라우터에 송신한다 

#### 패킷 송수신 동작의 개요

- TCP담당부분 -> IP담당부분으로 넘어갈때 TCP헤더를 부가한것을 IP담당부분에 넘긴다

- 이것이 패킷에 들어가는 내용물이되고, 통신상대의 IP주소를 나타낸다

- IP담당부분이 추가로하는일은 IP헤더(목적지 까지 패킷을 전달할때 사용하는 제어정보 포함)와 MAC헤더(가까운 라우터까지 패킷을 운반)를 부가한다

#### 수신처 IP주소를 기록한 IP헤더를 만든다 

IP담당부분 -> 네트워크용 하드웨어에 건네준다 

IP담당부분은 TCP가 어떻게 동작하든 관심없고 그저 목적지에 패킷을 수신한다 
송수신처의 IP주소를 모두 IP헤더에 설정한다 


#### 이더넷용 MAC헤더를 만든다 

송,수신처 MAC주소가 48비트로 포함되어있다.
수신처 MAC주소를 찾을때 누구에게 패킷을 건네주어야 할지 모르는데 어떻게 알고찾지?
=> 경로표의 GateWay항목에 IP주소를 참고한다 IP주소에서 Mac주소를 조사하는 동작을 실행한다

#### ARP로 수신처 라우터의 MAC주소를 조사한다

- 이더넷에 연결되어있는 전원에게 특정 IP주소를 가진 녀석을 찾고 발견하면 그녀석이 MAC주소를 돌려준다. 

- 같은 네트워크에 존재하면 MAC주소를 알수있다.
- 이때 사용되는것이 ARP이며 , ARP는 한번조사하고 나서  조사한내용을 캐시에 보존한다

- 이때 캐시의 내용이 업데이트되지않아 불일치 할수있기때문에 유효시간이 정해져있다.

- MAC주소를 조사할때는 ARP를 사용한다 


#### IP패킷을 전기나 빛의 신호로 변환하여 송신한다

LAN어댑터가 디지털 데이터를 전기나 빛의 신호로 변화하여 케이블에 송출한다 
이것이 송수신 동작의 본질이라고 볼수있다

LAN드라이버가 IP담당부분의 패킷을 받으면 버퍼 메모리에 복사하여 진행한다  




## UDP프로토콜을 이용한 송수신 동작

- TCP프로토콜은 데이터가 확실히 도착했는지 확인하는 과정이 포함되어있기때문에 상당히 복잡하다.

- TCP프로토콜의 안정성은 장점이지만 항상 TCP프로토콜만은 사용해야하는것은아니다

- 접속,연결끊기 같은 단계가 없다

- 오류가 발생해도 모른체한다. 일단 패킷을 보낸다 오류가발생하면 한번더 보내면 그만이다 

DNS서버에대한 조회등 제어용으로 실행하는 것은 한개의 패킷으로 끝날수 있는 작업이므로 UDP를 사용한다
UDP는 애플리케이션에서 송신데이터를 받으면 UDP헤더를 부가하고 IP에 의뢰하여 송신하기만 한다 



#### 음성 및 동영상 데이터

음성이나 동영상은 데이터의 도착에 오류가 생겨 다시보낸다고 했을때 영상이 멈추거나 음성이 끊길수있다. 
TCP와같이 응답을 확인하여 다시보내는 방식은 시간이 더 걸리기떄문에 마찬가지로 끊길수있다
이러한 경우 UDP로 보내게된다 데이터가 소실된다고 해도 영상이 잠시끊기거나 치직거리는 음성의 리스크를 안고 UDP로 보내는것이 효율적이기 때문이다 
